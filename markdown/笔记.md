## 组件

* 使用步骤：
1. 调用Vue.extend()方法`创建组件构造器`
2. 调用Vue.component()方法`注册组件`
3. 在Vue实例的作用范围内`使用组件`

说明：
*  使用Vue.component()注册组件时，需要提供2个参数，第1个参数时组件的标签，第2个参数是组件构造器。
* 组件应该`挂载`到某个Vue实例下，否则它不会生效。

1. 组件中`data`选项必须是一个函数，示例如下
```js
data: funcation() {
    return ｛
        count: 0
    ｝
}
```
而不是一个对象
```js
data: {
    count: 0
}

* 好处：每个实例之间互不干扰，单独维护每一份拷贝。

## 全局注册 & 局部注册
注册： 注册后才能被Vue识别，从而在模板中使用
全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生

全局注册： 
Vue.component("组件标签名", {
    // 其他属性，包含在对象内
})
此写法将创造组件构造器与全局注册合二为一，等价于：
var comName = Vue.extend({
    template: // 一些属性
});
Vue.component("组件标签名", comName)

* 可以用在其被注册之后的任何 通过 new Vue新创建的 Vue 根实例，也包括其组件树中的所有`子组件`的模板中


局部注册：在Vue实例中使用`components `指明需用用的组件
1. 创建组件构造器
    // 1.创建一个组件构造器
	var myComponent = Vue.extend({
		template: '<div>This is my first component!</div>'
    })
2. 在vue实例中使用components
new Vue({
    el: '#app',
    componments: {
        "my-component": myComponent
    }
})
3. 局部注册的组件可以


组件树的形式组成应用（各组件可能会使用其他一到多个组件）

## prop指定类型

```js
props: {
    titile: String,
    viewers: Number,
    isPublished: Boolean,
    commentIds: Array,
    author: Object,
    callback: Function
}
```

## 子组件及数据传递

props： 组件中注册一些自定义属性，当值通过prop.attribute传递值时，该值成为组件实例的一个属性。并且组件可以自由访问该属性值。

* 相当于输入参数

示例：
Vue.component('blog-post', {
    props: ['title'],
    template: "<h3>{{ title }}</h3>"
})

// 使用时,可通过标签属性传递
```js
<div id="demo">
    <blog-post title="如此使用”></blog-post>
</div>

new Vue({
    el: "#demo"
})
```

## 每个组件只能有一个根元素

可以使用  <div>`</div> 在template中多行编写

一个将对象作为`props`输入的例子

```js
<blog-post 
    v-for="post in posts"
    v-bind:id="post.id"
    v-bind:post-param="post"
></blog-post>

Vue.component('blog-post', {
    props: ['post-param'],
    template: `
        <div class="blog-post">
            <h3>{{ post-param.title }}</h3>
            <div v-html="post-param.content"></div>
        </div>
    `
})
```

## 监听子组件事件

目的：父级组件与子组件进行沟通（父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件）

1. 子组件在父组件中初始化时，可以编写`v-on`监听事件
2. 子组件模板中使用`$emit(方法名)` 来触发事件
3. `$emit` 的第二个参数可以向父组件返回值
示例如下

```js
<div id="demo">
    <div style="{fontSize: postFontSize + 'em'}">
        <blog-event-component
            v-bind:title="title"

            v-on:large-text="postFontSize += 0.1"
        ></blog-event-component>
    </div>
</div>

Vue.component("blog-event-component", {
    template: `
    <div class="blog-post">
      <h3>{{ title }}</h3>
      <button v-on:click="$emit('large-text')">
        Enlarge text
      </button>
    </div>
    `
})

new Vue({
    el: "#demo",
    data: {
        postFontSize: 1
    }
})
```

## v-model 与 v-bind

```js
<input v-model="selectValue">

等价于

<input 
    v-bind:value="selectValue"
    v-on:input="selectValue = $event.target.value">
```

当v-model 在组件上时，需要对组件中template做以下处理
* 将其 value attribute 绑定到一个名叫 value 的 prop 上
* 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出

## slot元素

在组件标签之间的内容，可以展示在组件中template中的`slot`标签中

* 作用域：父级模板的内容都在父级作用域中编译，子模板的所有内容都在子作用域中编译

### 具名插槽

* 可指定插槽名称（未指定的插槽名默认为default）
<slot name="slot-header"></slot>
在使用时通过template标签 及 v-slot指令使用
<template v-slot:slot-header>
    <div>hi</div>
</template>


## 动态组件

* 可以使用如下组件展示方法

<!-- 组件会在 `currentTabComponent` 改变时改变 -->
<component v-bind:is="currentTabComponent"></component>

## is 属性

> 请留意，`is` attribute 可以用于常规 HTML 元素，但这些元素将被视为组件，这意味着所有的 attribute 都会作为 DOM attribute 被绑定。对于像 value 这样的 property，若想让其如预期般工作，你需要使用 .prop 修饰器。

* eg:
<table>
  <tr is="blog-post-row"></tr>
</table>

